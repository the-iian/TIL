### JPA

> JPA와 Hibernate 차이점

- JPA - 기술 명세 인터페이스
- Hibernate - JPA의 구현체

> EntityManagerFactory

- DB당 하나만 생성

> EntityManager

- 고객 요청이 올때마다 썻다가 em.close();로 버리는식으로 동작한다
- 쓰레드간에 공유X (사용하고 버려야한다)

> 트랜잭션

- 데이터베이스 상태 변화를 위해 수행하는 작업 단위

> JPQL

- 엔티티 객체 대상 쿼리
- 쿼리를 짜놓으면 방언에 맞춰서 각 DB에 맞게 번역해준다
- 데이터 검색, 필터링 및 조작 (페이징할 때 편함)
- SQL 문법과 유사
- SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN 지원

> 영속성 컨텍스트 (EntityManager)

- 엔티티를 영구 저장하는 환경
- 엔티티를 DB가 아닌 영속성 컨텍스트라는곳에 저장한다
- EntityManager 내부에 영속성 컨텍스트가 눈에 보이진않지만 공간이 생긴다 
- EntityManagerFactory를 통해 고객의 요청이 오면 → EntityManager1 생성, 다른 요청이 오면 EntityManager2 생성 → EntityManager는 내부적으로 데이터베이스 커넥션을 사용해서 DB를 사용하게된다

> 비영속

- 객체를 생성한 상태 (세팅만 한 것)
- 엔티티 매니저가 비어있음

> 영속

- 객체를 저장한 상태
- 엔티티 매니저에 객체가 들어가면서 영속 상태가 된다
- JPA가 관리하는 상태
- persist로 객체를 집어넣거나, find로 가져온 상태

> 플러시 - 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영

- 수정된 엔티티 쓰지 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송
- 플러시해도 1차 캐시는 그대로 유지됨 (영속성 컨텍스트를 비우지 않음)
- JPQL 쿼리 실행시 플러시가 무조건 날라간다

> 영속성 컨텍스트를 플러시하는 방법

- em.flush() 강제호출 - 커밋되기전에 즉시 호출한다
- 트랜잭션 커밋 - 플러시 자동 호출
- JPQL 쿼리 실행 - 플러시 자동 호출
- FlushModeType.AUTO - 커밋 & 쿼리 실행할 때 플러시 (기본값)
- FlushModeType.COMMIT - 커밋할 때만 플러시

> 준영속 상태

- 영속 상태의 엔티티가 영속성 컨택스트에서 분리
- 영속성 컨택스트가 제공하는 기능을 사용 못함
- JPA에서 관리 안하기때문에 커밋해도 쿼리에 변함없음

> 준영속 상태로 만드는 방법

- em.detach(entity) - 특정 엔티티만 준영속 상태로 전환
- em.clear() - 영속성 컨텍스트를 완전히 초기화
- em.close() - 영속성 컨텍스트 종료
